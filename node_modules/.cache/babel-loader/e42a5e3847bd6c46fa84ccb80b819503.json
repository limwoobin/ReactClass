{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport getScrollbarSize from '../utils/getScrollbarSize';\nimport ownerDocument from '../utils/ownerDocument';\nimport isOverflowing from './isOverflowing';\nimport { ariaHidden, ariaHiddenSiblings } from './manageAriaHidden';\n\nfunction findIndexOf(data, callback) {\n  var idx = -1;\n  data.some(function (item, index) {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n\n    return false;\n  });\n  return idx;\n}\n\nfunction getPaddingRight(node) {\n  return parseInt(window.getComputedStyle(node)['padding-right'], 10) || 0;\n}\n\nfunction setContainerStyle(data) {\n  // We are only interested in the actual `style` here because we will override it.\n  data.style = {\n    overflow: data.container.style.overflow,\n    paddingRight: data.container.style.paddingRight\n  };\n  var style = {\n    overflow: 'hidden'\n  };\n\n  if (data.overflowing) {\n    var scrollbarSize = getScrollbarSize(); // Use computed style, here to get the real padding to add our scrollbar width.\n\n    style.paddingRight = \"\".concat(getPaddingRight(data.container) + scrollbarSize, \"px\"); // .mui-fixed is a global helper.\n\n    var fixedNodes = ownerDocument(data.container).querySelectorAll('.mui-fixed');\n\n    for (var i = 0; i < fixedNodes.length; i += 1) {\n      var paddingRight = getPaddingRight(fixedNodes[i]);\n      data.prevPaddings.push(paddingRight);\n      fixedNodes[i].style.paddingRight = \"\".concat(paddingRight + scrollbarSize, \"px\");\n    }\n  }\n\n  Object.keys(style).forEach(function (key) {\n    data.container.style[key] = style[key];\n  });\n}\n\nfunction removeContainerStyle(data) {\n  // The modal might be closed before it had the chance to be mounted in the DOM.\n  if (data.style) {\n    Object.keys(data.style).forEach(function (key) {\n      data.container.style[key] = data.style[key];\n    });\n  }\n\n  var fixedNodes = ownerDocument(data.container).querySelectorAll('.mui-fixed');\n\n  for (var i = 0; i < fixedNodes.length; i += 1) {\n    fixedNodes[i].style.paddingRight = \"\".concat(data.prevPaddings[i], \"px\");\n  }\n}\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\n\n\nvar ModalManager =\n/*#__PURE__*/\nfunction () {\n  function ModalManager() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ModalManager);\n\n    var _options$hideSiblingN = options.hideSiblingNodes,\n        hideSiblingNodes = _options$hideSiblingN === void 0 ? true : _options$hideSiblingN,\n        _options$handleContai = options.handleContainerOverflow,\n        handleContainerOverflow = _options$handleContai === void 0 ? true : _options$handleContai;\n    this.hideSiblingNodes = hideSiblingNodes;\n    this.handleContainerOverflow = handleContainerOverflow; // this.modals[modalIdx] = modal\n\n    this.modals = []; // this.data[containerIdx] = {\n    //   modals: [],\n    //   container,\n    //   overflowing,\n    //   prevPaddings,\n    // }\n\n    this.data = [];\n  }\n\n  _createClass(ModalManager, [{\n    key: \"add\",\n    value: function add(modal, container) {\n      var modalIdx = this.modals.indexOf(modal);\n\n      if (modalIdx !== -1) {\n        return modalIdx;\n      }\n\n      modalIdx = this.modals.length;\n      this.modals.push(modal); // If the modal we are adding is already in the DOM.\n\n      if (modal.modalRef) {\n        ariaHidden(modal.modalRef, false);\n      }\n\n      if (this.hideSiblingNodes) {\n        ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, true);\n      }\n\n      var containerIdx = findIndexOf(this.data, function (item) {\n        return item.container === container;\n      });\n\n      if (containerIdx !== -1) {\n        this.data[containerIdx].modals.push(modal);\n        return modalIdx;\n      }\n\n      var data = {\n        modals: [modal],\n        container: container,\n        overflowing: isOverflowing(container),\n        prevPaddings: []\n      };\n      this.data.push(data);\n      return modalIdx;\n    }\n  }, {\n    key: \"mount\",\n    value: function mount(modal) {\n      var containerIdx = findIndexOf(this.data, function (item) {\n        return item.modals.indexOf(modal) !== -1;\n      });\n      var data = this.data[containerIdx];\n\n      if (!data.style && this.handleContainerOverflow) {\n        setContainerStyle(data);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(modal) {\n      var modalIdx = this.modals.indexOf(modal);\n\n      if (modalIdx === -1) {\n        return modalIdx;\n      }\n\n      var containerIdx = findIndexOf(this.data, function (item) {\n        return item.modals.indexOf(modal) !== -1;\n      });\n      var data = this.data[containerIdx];\n      data.modals.splice(data.modals.indexOf(modal), 1);\n      this.modals.splice(modalIdx, 1); // If that was the last modal in a container, clean up the container.\n\n      if (data.modals.length === 0) {\n        if (this.handleContainerOverflow) {\n          removeContainerStyle(data);\n        } // In case the modal wasn't in the DOM yet.\n\n\n        if (modal.modalRef) {\n          ariaHidden(modal.modalRef, true);\n        }\n\n        if (this.hideSiblingNodes) {\n          ariaHiddenSiblings(data.container, modal.mountNode, modal.modalRef, false);\n        }\n\n        this.data.splice(containerIdx, 1);\n      } else if (this.hideSiblingNodes) {\n        // Otherwise make sure the next top modal is visible to a screen reader.\n        var nextTop = data.modals[data.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set\n        // aria-hidden because the dom element doesn't exist either\n        // when modal was unmounted before modalRef gets null\n\n        if (nextTop.modalRef) {\n          ariaHidden(nextTop.modalRef, false);\n        }\n      }\n\n      return modalIdx;\n    }\n  }, {\n    key: \"isTopModal\",\n    value: function isTopModal(modal) {\n      return !!this.modals.length && this.modals[this.modals.length - 1] === modal;\n    }\n  }]);\n\n  return ModalManager;\n}();\n\nexport default ModalManager;","map":{"version":3,"sources":["/Applications/woobeenkun/myBlog/client/node_modules/@material-ui/core/esm/Modal/ModalManager.js"],"names":["_classCallCheck","_createClass","getScrollbarSize","ownerDocument","isOverflowing","ariaHidden","ariaHiddenSiblings","findIndexOf","data","callback","idx","some","item","index","getPaddingRight","node","parseInt","window","getComputedStyle","setContainerStyle","style","overflow","container","paddingRight","overflowing","scrollbarSize","concat","fixedNodes","querySelectorAll","i","length","prevPaddings","push","Object","keys","forEach","key","removeContainerStyle","ModalManager","options","arguments","undefined","_options$hideSiblingN","hideSiblingNodes","_options$handleContai","handleContainerOverflow","modals","value","add","modal","modalIdx","indexOf","modalRef","mountNode","containerIdx","mount","remove","splice","nextTop","isTopModal"],"mappings":"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","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport getScrollbarSize from '../utils/getScrollbarSize';\nimport ownerDocument from '../utils/ownerDocument';\nimport isOverflowing from './isOverflowing';\nimport { ariaHidden, ariaHiddenSiblings } from './manageAriaHidden';\n\nfunction findIndexOf(data, callback) {\n  var idx = -1;\n  data.some(function (item, index) {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n\n    return false;\n  });\n  return idx;\n}\n\nfunction getPaddingRight(node) {\n  return parseInt(window.getComputedStyle(node)['padding-right'], 10) || 0;\n}\n\nfunction setContainerStyle(data) {\n  // We are only interested in the actual `style` here because we will override it.\n  data.style = {\n    overflow: data.container.style.overflow,\n    paddingRight: data.container.style.paddingRight\n  };\n  var style = {\n    overflow: 'hidden'\n  };\n\n  if (data.overflowing) {\n    var scrollbarSize = getScrollbarSize(); // Use computed style, here to get the real padding to add our scrollbar width.\n\n    style.paddingRight = \"\".concat(getPaddingRight(data.container) + scrollbarSize, \"px\"); // .mui-fixed is a global helper.\n\n    var fixedNodes = ownerDocument(data.container).querySelectorAll('.mui-fixed');\n\n    for (var i = 0; i < fixedNodes.length; i += 1) {\n      var paddingRight = getPaddingRight(fixedNodes[i]);\n      data.prevPaddings.push(paddingRight);\n      fixedNodes[i].style.paddingRight = \"\".concat(paddingRight + scrollbarSize, \"px\");\n    }\n  }\n\n  Object.keys(style).forEach(function (key) {\n    data.container.style[key] = style[key];\n  });\n}\n\nfunction removeContainerStyle(data) {\n  // The modal might be closed before it had the chance to be mounted in the DOM.\n  if (data.style) {\n    Object.keys(data.style).forEach(function (key) {\n      data.container.style[key] = data.style[key];\n    });\n  }\n\n  var fixedNodes = ownerDocument(data.container).querySelectorAll('.mui-fixed');\n\n  for (var i = 0; i < fixedNodes.length; i += 1) {\n    fixedNodes[i].style.paddingRight = \"\".concat(data.prevPaddings[i], \"px\");\n  }\n}\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\n\n\nvar ModalManager =\n/*#__PURE__*/\nfunction () {\n  function ModalManager() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ModalManager);\n\n    var _options$hideSiblingN = options.hideSiblingNodes,\n        hideSiblingNodes = _options$hideSiblingN === void 0 ? true : _options$hideSiblingN,\n        _options$handleContai = options.handleContainerOverflow,\n        handleContainerOverflow = _options$handleContai === void 0 ? true : _options$handleContai;\n    this.hideSiblingNodes = hideSiblingNodes;\n    this.handleContainerOverflow = handleContainerOverflow; // this.modals[modalIdx] = modal\n\n    this.modals = []; // this.data[containerIdx] = {\n    //   modals: [],\n    //   container,\n    //   overflowing,\n    //   prevPaddings,\n    // }\n\n    this.data = [];\n  }\n\n  _createClass(ModalManager, [{\n    key: \"add\",\n    value: function add(modal, container) {\n      var modalIdx = this.modals.indexOf(modal);\n\n      if (modalIdx !== -1) {\n        return modalIdx;\n      }\n\n      modalIdx = this.modals.length;\n      this.modals.push(modal); // If the modal we are adding is already in the DOM.\n\n      if (modal.modalRef) {\n        ariaHidden(modal.modalRef, false);\n      }\n\n      if (this.hideSiblingNodes) {\n        ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, true);\n      }\n\n      var containerIdx = findIndexOf(this.data, function (item) {\n        return item.container === container;\n      });\n\n      if (containerIdx !== -1) {\n        this.data[containerIdx].modals.push(modal);\n        return modalIdx;\n      }\n\n      var data = {\n        modals: [modal],\n        container: container,\n        overflowing: isOverflowing(container),\n        prevPaddings: []\n      };\n      this.data.push(data);\n      return modalIdx;\n    }\n  }, {\n    key: \"mount\",\n    value: function mount(modal) {\n      var containerIdx = findIndexOf(this.data, function (item) {\n        return item.modals.indexOf(modal) !== -1;\n      });\n      var data = this.data[containerIdx];\n\n      if (!data.style && this.handleContainerOverflow) {\n        setContainerStyle(data);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(modal) {\n      var modalIdx = this.modals.indexOf(modal);\n\n      if (modalIdx === -1) {\n        return modalIdx;\n      }\n\n      var containerIdx = findIndexOf(this.data, function (item) {\n        return item.modals.indexOf(modal) !== -1;\n      });\n      var data = this.data[containerIdx];\n      data.modals.splice(data.modals.indexOf(modal), 1);\n      this.modals.splice(modalIdx, 1); // If that was the last modal in a container, clean up the container.\n\n      if (data.modals.length === 0) {\n        if (this.handleContainerOverflow) {\n          removeContainerStyle(data);\n        } // In case the modal wasn't in the DOM yet.\n\n\n        if (modal.modalRef) {\n          ariaHidden(modal.modalRef, true);\n        }\n\n        if (this.hideSiblingNodes) {\n          ariaHiddenSiblings(data.container, modal.mountNode, modal.modalRef, false);\n        }\n\n        this.data.splice(containerIdx, 1);\n      } else if (this.hideSiblingNodes) {\n        // Otherwise make sure the next top modal is visible to a screen reader.\n        var nextTop = data.modals[data.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set\n        // aria-hidden because the dom element doesn't exist either\n        // when modal was unmounted before modalRef gets null\n\n        if (nextTop.modalRef) {\n          ariaHidden(nextTop.modalRef, false);\n        }\n      }\n\n      return modalIdx;\n    }\n  }, {\n    key: \"isTopModal\",\n    value: function isTopModal(modal) {\n      return !!this.modals.length && this.modals[this.modals.length - 1] === modal;\n    }\n  }]);\n\n  return ModalManager;\n}();\n\nexport default ModalManager;"]},"metadata":{},"sourceType":"module"}